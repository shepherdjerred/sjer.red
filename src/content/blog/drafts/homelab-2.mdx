---
title: Homelab 2 - Deno and cdk8s
description: Deno and cdk8s
date: 2024-10-14Z-0700
layout: ../../../layouts/BlogLayout.astro
isDraft: true
---

import Socratic from "../../../components/blog/Socratic.astro";
import Dialog from "../../../components/blog/Dialog.astro";

This is part of a series on my homelab. You can view [my code on GitHub](https://github.com/shepherdjerred/homelab/). I'm also happy to answer any questions you might have.

## `cdk` and `cdk8s`

If you've used CloudFormation, then you know how much it sucks. You use a weird dialect of YAML to define your AWS resources. Back in 2017 AWS introduced the [cdk](https://github.com/aws/aws-cdk) library. It allows you to generate your CloudFormation YAML using a _real_ language like Go, Python, Java, or TypeScript.

This idea turned out to be execellent, so they did the same thing for Kubernetes with [cdk8s](https://cdk8s.io/). cdk8s seems to be abandonded, but it still works quite well. Since the TypeScript defitions are generated from Kubernetes' resources (including third-party custom resource definitions!), the library should continue to work for quite a while longer.

Here's a "hello world" program from cdk8s' documentation:

```typescript
// @noErrors
import { Construct } from "constructs";
import { App, Chart } from "cdk8s";
import { KubeDeployment } from "./imports/k8s";

class MyChart extends Chart {
  constructor(scope: Construct, ns: string, appLabel: string) {
    super(scope, ns);

    // Define a Kubernetes Deployment
    new KubeDeployment(this, "my-deployment", {
      spec: {
        replicas: 3,
        selector: { matchLabels: { app: appLabel } },
        template: {
          metadata: { labels: { app: appLabel } },
          spec: {
            containers: [
              {
                name: "app-container",
                image: "nginx:1.19.10",
                ports: [{ containerPort: 80 }],
              },
            ],
          },
        },
      },
    });
  }
}

const app = new App();
new MyChart(app, "getting-started", "my-app");

app.synth();
```

The result of running this program is a Kubernetes YAML file that you can deploy using `kubectl apply`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: getting-started-my-deployment-c85252a6
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - image: nginx:1.19.10
          name: app-container
          ports:
            - containerPort: 80
```

Why is this useful? Static typing! cdk8s can inform guide you as you write your Kubernetes resources. For example, it can let you know what properties are valid when you're creating a resource or let you know when you've specifiy an invalid property.

<Dialog>
  <Socratic perspective="student">
    Surely Kubernetes has linters and IDE integrations for YAML to catch the same issues?
  </Socratic>
  <Socratic perspective="teacher">
    I'm sure that it does! In fact, I used one of these linters on my YAML output to catch additional misconfigurations.
    I was already familiar with cdk and TypeScript. I also just really like both of those technologies, so I chose to
    stick with them.
  </Socratic>
</Dialog>

cdk8s has support for all of Kubernete's resources. These definitions are generated by the [`cdk8s import`](https://cdk8s.io/docs/latest/cli/import/) command, which generates types for every Kubernetes resource on your server including CRDs (custom resource definitions). Here's an example of a generated definition for 1Password, which I use to handle all of the secrets in my Kubernetes cluster:

```typescript
// @noErrors
export class OnePasswordItem extends ApiObject {
  public constructor(scope: Construct, id: string, props: OnePasswordItemProps = {}) {
    super(scope, id, {
      ...OnePasswordItem.GVK,
      ...props,
    });
  }
}

export interface OnePasswordItemProps {
  readonly metadata?: ApiObjectMetadata;
  readonly spec?: OnePasswordItemSpec;
  readonly type?: string;
}

export interface OnePasswordItemSpec {
  readonly itemPath?: string;
}
```

Here's how I use it to store my Tailscale key:

```typescript
// @noErrors
new OnePasswordItem(chart, "tailscale-operator-oauth-onepassword", {
  spec: {
    itemPath: "vaults/v64ocnykdqju4ui6j6pua56xw4/items/mboftvs4fyptyqvg3anrfjy6vu",
  },
  metadata: {
    name: "operator-oauth",
    namespace: "tailscale",
  },
});
```

Takeaway: cdk8s supports all Kubernetes resources, including third-party resources from 1Password, Tailscale, Traefik, etc.

## Deno

Okay, so we have a way to write our all of our Kubernetes definitions in TypeScript. How do we actually compile our TypeScript to YAML?

The traditional way would be to use NodeJS, install TypeScript, compile the TypeScript to JavaScript, and then execute the result. This would work just fine!

However, I'm not a big fan of Node and would prefer to use a tool with TypeScript support built-in. I love the modern toolchains that languages like Rust and Go have. You can get something similar for TypeScript with [Deno](https://deno.com/) and [Bun](https://bun.sh/) which are alternatives to NodeJS with native TypeScript support.

I've only really used Deno, so that's what I'll be showing in this post. I'm sure that Bun would work similarly well!

You'll need to [install Deno](https://docs.deno.com/runtime/) -- this will include everything you need to compile and run a TypeScript program.

Deno has a few quirks -- most of them are around imports. With Node you declare your dependencies in a `package.json` and your code will pull from `node_modules`. With Deno you declare your dependencies (and their versions) in your code and Deno will take care of downloading at runtime.

Because of this, the import format is a bit different. Rather than directly calling `cdk8s import`, we can use this script to create the correct imports for our generated Kubernetes types.

```typescript
// @noErrors
#!/usr/bin/env -S deno run --allow-run --allow-read --allow-write

// delete the imports directory
await Deno.remove("imports", { recursive: true });

// run "cdk8s import k8s --language=typescript"
let command = new Deno.Command("cdk8s", {
  args: ["import", "k8s", "--language=typescript"],
});
console.log(new TextDecoder().decode((await command.output()).stdout));

// run "kubectl get crds -o json | cdk8s import /dev/stdin --language=typescript"
command = new Deno.Command("bash", {
  args: [
    "-c",
    "kubectl get crds -o json | cdk8s import /dev/stdin --language=typescript",
  ],
});
console.log(new TextDecoder().decode((await command.output()).stdout));

const files = Deno.readDir("imports");

// add "// deno-lint-ignore-file" to the top of each file in the imports directory
for await (const file of files) {
  if (file.isFile) {
    const filePath = `imports/${file.name}`;
    const content = await Deno.readTextFile(filePath);
    await Deno.writeTextFile(
      filePath,
      `// deno-lint-ignore-file\n${content}`,
    );
  }
}

// look for "public toJson(): any {", change this to "public override toJson(): any {"
// fixes This member must have an 'override' modifier because it overrides a member in the base class 'ApiObject'.
for await (const file of files) {
  if (file.isFile) {
    const filePath = `imports/${file.name}`;
    let content = await Deno.readTextFile(filePath);
    content = content.replaceAll(
      "public toJson(): any {",
      "public override toJson(): any {",
    );
    await Deno.writeTextFile(
      filePath,
      content,
    );
  }
}

// replace the npm import with the deno import
for await (const file of files) {
  if (file.isFile) {
    const filePath = `imports/${file.name}`;
    let content = await Deno.readTextFile(filePath);
    content = content.replaceAll(
      "from 'cdk8s'",
      "from 'https://esm.sh/cdk8s@2.68.58'",
    );
    content = content.replaceAll(
      "from 'constructs'",
      "from 'https://esm.sh/constructs@10.3.0'",
    );
    await Deno.writeTextFile(
      filePath,
      content,
    );
  }
}

// run deno fmt
command = new Deno.Command("deno", {
  args: ["fmt", "imports"],
});
console.log(new TextDecoder().decode((await command.output()).stdout));
```

We can save this file and then run it with the `deno` command line, e.g. `deno <file>`.

Next, we'll need to update our app's imports. We can take the program we wrote up above and change the imports to use [esm.sh](https://esm.sh/).

```typescript
// @noErrors
import { Construct } from "https://esm.sh/constructs@10.3.0";
import { App, Chart } from "https://esm.sh/cdk8s@2.68.58";
import { KubeDeployment } from "./imports/k8s";
```

Now, assuming our code is stored in `app.ts`, we can run `deno run app.ts`. This will compile our TypeScript code to Kubernetes YAML using Deno. Just like before, we can use `kubectl apply` to actually create these resources.

## Conclusion

In the past two posts I've shown you how to create a Kubernetes cluster using k3s and use cdk8s + Deno to deploy resources to your cluster. In my next post I'll cover automating deployments using ArgoCD.
