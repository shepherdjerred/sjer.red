---
title: Homelab 2 - Deno and cdk8s
description: Deno and cdk8s
date: 2024-06-26Z-0700
layout: ../../../layouts/BlogLayout.astro
isDraft: true
---

import Socratic from "../../../components/Socratic.astro";
import Dialog from "../../../components/Dialog.astro";

## `cdk` and `cdk8s`

If you've used CloudFormation, then you know how much it sucks. You use a weird dialect of YAML to define your AWS resources. Back in 2017 AWS introduced the [cdk](https://github.com/aws/aws-cdk) library. It allows you to generate your CloudFormation YAML using a _real_ language like Go, Python, Java, or TypeScript.

This idea turned out to be execellent, so they did the same thing for Kubernetes with [cdk8s](https://cdk8s.io/). cdk8s seems to be abandonded, but it still works quite well. Since the TypeScript defitions are generated from Kubernetes' resources (including third-party custom resource definitions!),the library should continue to work for quite a while longer.

Here's a "hello world" program from cdk8s' documentation:

```typescript
// @noErrors
import { Construct } from "constructs";
import { App, Chart } from "cdk8s";
import { KubeDeployment } from "./imports/k8s";

class MyChart extends Chart {
  constructor(scope: Construct, ns: string, appLabel: string) {
    super(scope, ns);

    // Define a Kubernetes Deployment
    new KubeDeployment(this, "my-deployment", {
      spec: {
        replicas: 3,
        selector: { matchLabels: { app: appLabel } },
        template: {
          metadata: { labels: { app: appLabel } },
          spec: {
            containers: [
              {
                name: "app-container",
                image: "nginx:1.19.10",
                ports: [{ containerPort: 80 }],
              },
            ],
          },
        },
      },
    });
  }
}

const app = new App();
new MyChart(app, "getting-started", "my-app");

app.synth();
```

The result of running this program is a Kubernetes YAML file that you can deploy using `kubectl apply`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: getting-started-my-deployment-c85252a6
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - image: nginx:1.19.10
          name: app-container
          ports:
            - containerPort: 80
```

Why is this useful? Static typing! cdk8s can inform guide you as you write your Kubernetes resources. For example, it can let you know what properties are valid when you're creating a resource or let you know when you've specifiy an invalid property.

<Dialog>
  <Socratic perspective="student">
    Surely Kubernetes has linters and IDE integrations for YAML to catch the same issues?
  </Socratic>
  <Socratic perspective="teacher">
    I'm sure that it does! In fact, I used one of these linters on my YAML output to catch additional misconfigurations.
    I was already familiar with cdk and TypeScript. I also just really like both of those technologies, so I chose to
    stick with them.
  </Socratic>
</Dialog>

cdk8s has support for all of Kubernete's resources. These definitions are generated by the [`cdk8s import`](https://cdk8s.io/docs/latest/cli/import/) command, which generates types for every Kubernetes resource on your server including CRDs (custom resource definitions). Here's an example of a generated definition for 1Password, which I use to handle all of the secrets in my Kubernetes cluster:

```typescript
// @noErrors
export class OnePasswordItem extends ApiObject {
  public constructor(scope: Construct, id: string, props: OnePasswordItemProps = {}) {
    super(scope, id, {
      ...OnePasswordItem.GVK,
      ...props,
    });
  }
}

export interface OnePasswordItemProps {
  readonly metadata?: ApiObjectMetadata;
  readonly spec?: OnePasswordItemSpec;
  readonly type?: string;
}

export interface OnePasswordItemSpec {
  readonly itemPath?: string;
}
```

Here's how I use it to store my Tailscale key:

```typescript
// @noErrors
new OnePasswordItem(chart, "tailscale-operator-oauth-onepassword", {
  spec: {
    itemPath: "vaults/v64ocnykdqju4ui6j6pua56xw4/items/mboftvs4fyptyqvg3anrfjy6vu",
  },
  metadata: {
    name: "operator-oauth",
    namespace: "tailscale",
  },
});
```

Takeaway: cdk8s supports all Kubernetes resources, including third-party resources from 1Password, Tailscale, Traefik, etc.

## Deno

TODO: write about Deno
